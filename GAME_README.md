# Система Крюк-Кошки для Godot

## Описание

Система крюк-кошки позволяет игроку запускать крюк в направлении курсора мыши. Крюк может цепляться за объекты в игровом мире и предоставляет основу для дальнейшего развития механик зацепления.

**Новые возможности:**

- ✅ Крюк движется вместе с движущимися объектами (корабли, враги)
- ✅ Автоматическое определение типа объекта (движущийся/статичный)
- ✅ Автоматический возврат при уничтожении прикрепленного объекта
- ✅ Автоматический возврат при слишком близком расстоянии к игроку
- ✅ Принудительный возврат крюка клавишей Escape

## Файлы системы

- `Scripts/Player/grappling_hook.gd` - Основная система крюк-кошки
- `Scripts/Player/player_grappling_integration.gd` - Интеграция крюк-кошки с игроком
- `Scripts/Player/player.gd` - Основной скрипт игрока (обновлен для подключения)
- `Scripts/test_object.gd` - Тестовый объект для проверки зацепления
- `Scripts/demo_scene.gd` - Демонстрационная сцена

## Архитектура

### Разделение ответственности

- **`GrapplingHook`** - Основная логика крюка (полет, коллизии, состояния)
- **`PlayerGrapplingIntegration`** - Интеграция с игроком (ввод, сигналы, управление)
- **`Player`** - Основная логика игрока + простое подключение крюка

### Преимущества архитектуры

- ✅ **Модульность** - каждый компонент отвечает за свою область
- ✅ **Переиспользование** - интеграцию можно использовать с разными игроками
- ✅ **Чистота кода** - основной скрипт игрока остается простым
- ✅ **Расширяемость** - легко добавлять новые механики

## Управление

- **WASD** - Движение игрока
- **Правая кнопка мыши (ПКМ)** - Запуск/отзыв крюка
- **Escape** - Принудительный возврат крюка
- Крюк автоматически возвращается при:
  - **Уничтожении прикрепленного объекта** (через сигналы или проверку состояния)
  - Слишком близком расстоянии к движущемуся объекту (менее 50 пикселей)
  - Достижении максимальной дальности
  - Притягивании к обломкам корабля (после достижения расстояния 80 пикселей)
  - **Удалении объекта из сцены** (queue_free())
- **R** - Перезагрузка сцены (в демо)

### Примечание по управлению

- Крюк запускается **только правой кнопкой мыши** - это исключает конфликты с другими механиками
- Пробел используется **исключительно для доджа**
- Escape используется для отмены/отсоединения крюка

## Особенности

### Базовая функциональность

- ✅ Запуск крюка по правой кнопке мыши
- ✅ Полет крюка в направлении курсора
- ✅ Коллизия с объектами
- ✅ Визуализация веревки
- ✅ Ограничение максимальной дистанции
- ✅ Автоматический возврат при превышении дистанции

### Состояния крюка

1. **IDLE** - Крюк неактивен
2. **FLYING** - Крюк летит к цели
3. **ATTACHED** - Крюк прикреплен к объекту
4. **RETRACTING** - Крюк возвращается к игроку

### Настраиваемые параметры

- `hook_speed` - Скорость полета крюка (по умолчанию: 1200.0 - увеличена для быстрого действия)
- `max_hook_distance` - Максимальная дальность (по умолчанию: 600.0)
- `hook_size` - Размер коллизии крюка (по умолчанию: 8.0)

## Механика полета

### Фиксированный угол полета

- При клике **запоминается угол** между игроком и курсором
- Крюк летит под этим **фиксированным углом** относительно игрока
- При движении игрока **угол сохраняется** - крюк всегда летит в том же направлении относительно игрока
- Крюк летит до **максимальной дистанции** в выбранном направлении

### Поведение при движении игрока

- Крюк **следует за игроком**, сохраняя первоначальный угол
- Целевая точка крюка = позиция игрока + направление под углом × максимальная дистанция
- При достижении максимальной дистанции крюк автоматически возвращается

### Ограничения дистанции

- Максимальная дистанция считается от **текущей позиции игрока**
- Крюк не может улететь дальше установленного лимита

## Механика доджа

### Основные особенности

- **Активация**: Нажатие пробела при удержании клавиш движения (WASD)
- **Направление**: Додж выполняется в направлении нажатых клавиш движения
- **Условие**: Игрок должен **активно нажимать** клавиши движения (WASD)
- **Перезарядка**: После использования додж недоступен в течение `dodge_cooldown` секунд

### Настраиваемые параметры доджа

- `dodge_force` - Сила доджа (по умолчанию: 800.0)
- `dodge_cooldown` - Время перезарядки в секундах (по умолчанию: 1.0)

### Логика работы

1. **Удерживаете WASD** - игрок готов к доджу
2. **Нажимаете пробел** - выполняется додж в направлении WASD
3. **Отпускаете WASD** - додж недоступен, даже если игрок еще движется по инерции

### Утилитарные методы

- `can_dodge()` - Проверяет возможность выполнения доджа (не на перезарядке + нажаты клавиши движения)
- `is_dodge_on_cooldown()` - Проверяет, на перезарядке ли додж
- `get_dodge_cooldown_remaining()` - Возвращает оставшееся время перезарядки
- `get_dodge_cooldown_progress()` - Возвращает прогресс перезарядки (0.0-1.0)

## Визуальные особенности

### Якорь

- Использует SVG изображение `Assets/Images/Player/anchor.svg`
- Автоматически поворачивается в направлении движения
- Масштабируется до 50% от оригинального размера

### Веревка

- Белого цвета для лучшей видимости
- Ширина линии: 3 пикселя
- Отображается позади других объектов

## Интеграция

### Автоматическое подключение

Система автоматически подключается при создании игрока:

```gdscript
# В player.gd уже есть:
func setup_grappling_integration():
    grappling_integration = PlayerGrapplingIntegration.new()
    add_child(grappling_integration)
    grappling_integration.setup_for_player(self)
```

### Ручное подключение к существующему игроку

```gdscript
# Создаем интеграцию
var grappling_integration = PlayerGrapplingIntegration.new()
player.add_child(grappling_integration)
grappling_integration.setup_for_player(player)
```

### Переопределение методов событий

В скрипте игрока можно переопределить методы для обработки событий крюка:

```gdscript
func on_hook_attached(position: Vector2):
    print("Крюк прикреплен!")
    # Ваша логика

func on_hook_hit_target(body: Node2D):
    if body.is_in_group("enemies"):
        # Логика для врагов
        pass
```

### Создание зацепляемых объектов

Объекты должны иметь коллизию и могут содержать метод `can_be_grappled()`:

```gdscript
extends StaticBody2D

func can_be_grappled() -> bool:
    return true

func on_grappled():
    print("Объект зацеплен!")
```

## Сигналы

- `hook_attached(position: Vector2)` - Крюк прикрепился
- `hook_detached()` - Крюк отсоединился
- `hook_hit_target(body: Node2D)` - Крюк попал в объект

## Методы для расширения

### В GrapplingHook:

- `can_attach_to(body: Node)` - Проверка возможности зацепления
- `get_attachment_point(body: Node)` - Получение точки крепления
- `apply_hook_force(force: Vector2)` - Применение силы к объекту

### В Player:

- `start_swinging_mechanics()` - Механика раскачивания
- `start_pulling_mechanics(target_body)` - Механика подтягивания

## Будущие возможности

Система подготовлена для добавления:

1. **Механика раскачивания** - Игрок может раскачиваться на крюке
2. **Подтягивание к объектам** - Быстрое перемещение к точке крепления
3. **Подтягивание объектов** - Притягивание легких объектов к игроку
4. **Разные типы крюков** - Магнитный, взрывной, временный
5. **Улучшения веревки** - Физическая симуляция, натяжение
6. **Звуковые эффекты** - Звуки запуска, попадания, натяжения

## Отладка

Система выводит отладочную информацию в консоль:

- Запуск крюка и направление
- Попадания в объекты
- Смена состояний

## Требования

- Godot 4.x
- Система должна быть добавлена как дочерний узел основной сцены
- Игрок должен быть типа CharacterBody2D или Node2D

## Механика движения с объектами

### Автоматическое определение объектов

Система автоматически определяет тип объекта при попадании крюка:

**Движущиеся объекты:**

- CharacterBody2D и RigidBody2D
- Объекты в группах "enemies" или "moving_objects"
- Объекты с методами `get_ship_velocity()` или `get_current_speed()`
- Корабли (по имени скрипта содержащему "ship" или "enemy")

**Статичные объекты:**

- Все остальные объекты (астероиды, стены, препятствия)

### Поведение крюка

**При попадании в движущийся объект:**

1. Крюк вычисляет смещение точки крепления относительно объекта
2. Каждый кадр обновляет свою позицию: `позиция_объекта + смещение`
3. Следит за состоянием объекта (жив ли корабль)
4. Автоматически возвращается при уничтожении или слишком близком расстоянии

**При попадании в статичный объект:**

- Крюк остается в фиксированной позиции
- Работает как обычная точка зацепления

**При попадании в обломки корабля:**

1. Крюк определяет, что корабль уничтожен (метод `is_alive()` возвращает `false`)
2. Обломки считаются статичными объектами для зацепления
3. Игрок автоматически притягивается к обломкам на расстояние 80 пикселей
4. Крюк автоматически возвращается после притягивания
5. Обломки подсвечиваются голубым цветом при зацеплении
6. Можно использовать для быстрого перемещения по полю боя

### Визуальные эффекты зацепления

- **Живые корабли**: Нет особых эффектов (крюк следует за кораблем)
- **Обломки кораблей**: Голубое свечение на 0.5 секунды
- **Астероиды**: Желтое свечение на 0.3 секунды

### Отслеживание уничтожения объектов

Система использует несколько методов для отслеживания уничтожения прикрепленных объектов:

**1. Подключение к сигналам:**

- `tree_exiting` - стандартный сигнал Godot при удалении узла
- `ship_destroyed` - кастомный сигнал для кораблей
- `destroyed` - кастомный сигнал для астероидов

**2. Проверка состояния объекта:**

- `is_instance_valid()` - проверяет, существует ли объект в памяти
- `is_alive()` - для объектов с методом проверки жизни
- `is_destroyed()` - для объектов с методом проверки уничтожения
- `is_queued_for_deletion()` - для объектов, готовящихся к удалению

**3. Частота проверок:**

- Каждый кадр в `_process()` для прикрепленных объектов
- При обновлении позиции в `update_attached_hook_position()`
- Немедленно при получении сигналов уничтожения

**4. Автоматическая очистка:**

- Отключение всех сигналов при возврате крюка
- Очистка ссылок на уничтоженные объекты
- Предотвращение утечек памяти

### Новые методы API

```gdscript
# Проверка типа прикрепления
if hook.is_attached_to_moving_target():
    print("Крюк следует за движущимся объектом")

# Получение прикрепленного объекта
var target = hook.get_attached_target()
if target and target.has_method("is_alive"):
    print("Объект жив: ", target.is_alive())

# Получение расстояния до объекта
var distance = hook.get_distance_to_attached_target()
print("Расстояние до цели: ", distance)

# Принудительный возврат
hook.force_retract()

# Получение смещения крепления
var offset = hook.get_attachment_offset()
print("Смещение крепления: ", offset)
```
